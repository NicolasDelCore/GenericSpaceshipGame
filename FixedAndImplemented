Fixed and implemented, Pre-Alpha & Alpha 1.0:

Notes, each time a line starts with:
Implementation: Something new has been added.
Implementation change, xxxxx: Something already implemented has been reworked, changing the way it functions (whether to fix a major problem, improve on the feature or give it a new functionality).
Bug #: A description of how the bug looks like from the player's perspective.
a) b) c) (and so on): A description of how the bug looks like from the player's perspective, but these pointers are used when more than one bug either have the same cause or is fixed by the same fix.
-Lines starting with dashes explain the causes of a bug.
Fix #: A description of the fix implemented.

Implementation: Sprites.
Implementation: Player movement (aims in the direction of the mouse, moves with AWSD or arrow keys) in playerMovement script.
Implementation: Player shooting & particle effect on impact. There are two scripts for this: shooting and bullet. Shooting contains the force the bullet is suppoused to have on spawn and also instantiates the bullet itself. The bullet script destroys the bullet when a) it collides with something, or b) when a 1-second timer expires, it also contains the particle effect to be used on bullet impact/expiration. The bullets spawn from the firePoint gameobject, a child object to the player (it's an empty gameobject, just to mark where the bullet is suppoused to spawn).
Implementation: Copied player code to rotate, applied it to the enemyIA script. Instead of rotating to point to the mouse, the enemy will rotate to point to the player when the player enters the enemyVision zone.
Implementation: Copied the player-bullet script, changed its sprite and renamed it enemy-bullet. Copied the player shooting code & and applied it to the enemyIA and the enemy-bullet. Now, when the player enters the enemyVision zone, the flag playerFound is set to true, and the enemy will start shooting (and since it's already looking in the direction of the player, the enemy bullets will go in that direction, as the enemy-bullet spawn point is in front of the enemy).
Implementation: Enemies move based on AddForce. When the player is found, they move towards the player, but movement isn't very nice.
Implementation change, PathFinder script: in order to trace the path from the enemy to the player and move the enemy more smoothly, I've decided to implement the pathfinder script (which was faster than creating a new script, and also free). The enemies were trying to take the exact same position as the player, so to change this and have more control about where the enemy goes, I've attached a child gameobject called playerLastPos to the enemy. This gameobject has a script to update its position based on different circumtances. When the player is within the enemyVision zone, playerLastPos takes the player position, so the enemy moves towards the player. When the player is outside of the enemyVision zone (playerFound = false in the enemyIA script), playerLastPos takes the position of the enemy, so the enemy stops moving. 
Implementation: Map borders were momentarily solid during this early testing. I replaced the solid collision boxes with triggers and now the player and the enemies teleport to the opposite side of the map when hitting a map border.

Bug 1: Enemy turning around and choosing a larger path to the player.
-If the player just teleported through a map-border, the player position wasn't lost fast enough by the enemyIA script, so PlayerLastPos object (that points the enemy where to go) was getting the player position from the other side of the map, making the enemy turn around to face the player and go in that direction instead of through the map border portal.
Fix 1: The enemy now has access to see the player.teleporting bool, when this bool is set to True, lastPlayerPos won't be updated and the enemy won't rotate to face the player.

Implementation change, map borders: Previously, the teleport instructions were within both the playerMovement and enemyIA scripts (so the borders of the map were just script-free triggers). I moved the teleporting instructions to a script in each wall. Then I decided to simplify and unify the four scripts into one script that could be applied to the four walls at the same time (mapBorders script), as to avoid having to modify 4 scripts each time I wanted to make a change to the way the map borders work.

Bug 2:
a) Enemies would randomly disappear and reappear even when chasing the player.
b) In some occasions, the enemy would start "blinking" a lot of times per second and randomly ignore the player bullets. c) Bullets would disappear at certain places too.
-Bullets were getting teleported in the mapborders, thus you could step at a certain point and see the bullet disappear.
-The enemies would be teleported as soon as their enemyVision zone got in contact with the map border. Because of the size of the enemyVision zone, this could, in many cases, trap the enemy in question within a teleport-loop (they would teleport from one border to the other lots of times per second, visually blinking a lot and randomly ignoring player-bullets).
Fix 2: Within the mapBorders script, I added an "if" instruction to ignore triggerEnter and triggerExit events from the objects with name "enemyVision", "enemy-bullet(Clone)",  and "player-bullet(Clone)". This is so that the enemyVision trigger box is ignored, otherwise enemies would get trapped in a TP loop since the trigger box is too big. Bullets are now also ignored (instead of dissappearing, they pass through the trigger, this improves the illusion of going through an infinite space).

Implementation change, follow up: I added an empty game-object as child to the enemy game object. This empty game object, FollowUpPos, simply marks a point in front of the enemy. When the player is lost and the enemy reaches the last known position of the player (marked by the PlayerLastPos object), the PlayerLastPos object (which is what the enemy actually follows) will move to the FollowUpPos object's location once, making the enemy move forward like if it was still trying to chase after the player.

Bug 3: Sometimes, if the enemy is chasing the player and the player successfully escapes, the enemy will continue to traverse the same straight-line path forever (if undisturbed by the player).
-If the player escapes at just the right moment during a map-border-teleport, the PlayerLastPos gets stucked in the middle of (or beyond the) mapBorder trigger, making the enemy traverse the same straight path forever since it can't get to the PlayerLastPos object (because it's teleported to the other side of the map before that can happen, unless the player takes the enemy out of that loop by allowing himself to be detected, updating PlayerLastPos in the process).
Fix 3: Within the findingPlayerLastPos script (attached to the playerLastPos object), I included a check to see if the enemy's teleport flag is true or not (this flag is updated by the mapBorders script when the enemy object is detected). If the enemy teleport flag is true, the playerLastPos game object will be updated to the enemy's location. This prevents the playerLastPos GameObject from getting "stuck" in the teleporting map-borders (which would force the enemy to always travel the same path from border to border).

Bug 4: Sometimes, when the a) player or the b) enemy teleports from one mapborder to the other, for a split-second they'll be looking in the wrong direction.
a) In the case of the player looking at the wrong direction, it's because the player object teleports, but for that split second it'll detect the mouse as being behind it, and because the ship looks in the mouse direction, it'll flip before self-correcting after a few frames.
b) In the case of the enemy looking at the wrong direction, it's because it was chasing the player when it teleported, but the same concept as in point a) applies (the enemy will detect the player to be behind itself for a split-second, before self-correcting after a few frames).
c) Instead of following the player through the map border when the player is lost, the enemy just turns to the opposite side and moves forward.
-If the player just teleported, the followUp gameobject will point the enemy backwards instead of forward (into the teleporter). This is likely because the enemy is rotating to face the player right after this one is lost (for a split-second).
Fix: Rotation & movement is now disabled when teleporting. The player.teleporting and enemy.teleporting flags are now updated by the mapBorders script, these flags are set to true by triggerEnter and set to false by triggerExit. Within the playerMovement and enemyIA scripts, movement / rotation is disabled when these flags are true.

Bug 5:
a) Sometimes, the player will be unable to move.
-While being chased by the enemy, if the enemy went through the map borders at the exact moment, the player would be left in a "teleporting = true" state, so player wouldn't be able to move or rotate (unless the enemy pushed it towards a map border too).
b) Unity warning during dev about trying to access a destroyed object.
-If the enemy or enemy bullet is destroyed within a map border trigger at the right time, the map border trigger will try to access the object while it's being destroyed. Unity complains about this although it doens't represents a huge deal (it's simply a warning, but it only happens once and only if the object in question is destroyed at a exact place at a very specific time).
Fix: The problem here was that I thought it would be "better" if the mapBorder script saved the objects entering the trigger into variables, to reduce the <GetComponent> calls (as some places say that's a good practice). What was happening is that the mapborders script would cache (for example) the player entering the map border trigger, then before it could register the triggerExit event from the player, the enemy would take that value within the variable, so the triggerExit would never occur for the player, thus the teleporting bool wouldn't be set to false again. The same thing was provoking the warnings for the bullets/enemies being destroyed in the middle of the trigger zone. At the end of the day, and given the way these triggers access objects, it'll be more problematic and less benefitial to store the objects that go through in variables (specially considering the amount of bullets that could enter, exit and expire within the trigger).

Bug 6: Enemy tries to take the same position as the player, pushing the player forever. Pathfinder has a setting for stopping before reaching the objective, but it slowed down the following of the player by too much.
Fix: Implemented an enemyZone (like the enemyVision, but smaller). If the player enters this zone, the playerLastPos object will update its position to match the enemy's, preventing the enemy ships from pushing the player forever.

Bug 7: 
a) Sometimes, the enemy ship will stop following the player too soon. (Not really noticeable during gameplay).
-This happened because the player teleported. The followUp action would kick in early (before the enemy had reached the last position where the player was seen), making it travel a shorter distance than what its suppoused to travel.
Fix: Introduced a new flag in the enemyIA script, "hasPlayerTeleported". This bool will check the playerMovement script to see if the teleporting flag is true or not. If player.teleporting is true in the playerMovement script and if the playerFound flag is also true in the enemyIA script, hasPlayerTeleported will be set to true, and in that case, it'll turn the followUp flag in the enemyIA script to true as well. After the followUp action is done, the hasPlayerTeleported bool will be set to false by the findingPlayeterLastPos script (within the playerLastPos gameobject).

Bug 8:
-I'm including here all of "trying to access a destroyed object" errors that Unity prompted when either the enemy or the player was destroyed.
Fix: Introduced (and included where missing) a variable for each script that interacts with the player and/or the enemy to check if the entity in question is alive or not (isPlayerAlive / isEnemyAlive). These bools will be false when HP = 0 and true when not.

Implemented: Radar (script by Justin Zaun)

Bug 9: The radar would update the enemy position in the X axis, but not in the Y axis.
-The radar script was using X and Z axis to update itself (it was probably tailored for 3D I pressume).
Fix: Swapped the Z axis reference in the radar script for a reference to the Y axis.

Implemented: GUI, main menu
Implemented: GUI, pause menu
Implemented: GUI, death menu

Bug 10: If you paused the game, you were still able to spawn a new bullet (it would froze in spawn and die when the game was resumed).
Fix: Added a new bool to check if the game is paused or not. Added this to the player's shooting script and the enemyIA script.

Bug 11: If you died, then go to the main menu and then start a new game, the player wouldn't be able to move.
-The isPlayerAlive bool would not be updated, so the player would start a new game with that bool in false and couldn't move, but because its HP would be 30 instead of 0, the death menu wouldn't prompt either.
Fix: Starting a new game from the Restart button or from the main menu will always force the isPlayerAlive bool to be true, and the isGamePaused bool to be false.

Implemented: enemyPrefab (a prefab with the enemy object).
Bug 12: enemies spawned from enemyPrefab were quiet and doing almost nothing or moving weirdly.
-It wasn't working because the prefab would delink itself from certain objects (the player, the score system, the spawner).
Fix: I had to modify the enemyIA a bit to look for the problematic values on the Start() method (as soon as the object spawns basically). 

Implemented: Spawner gameobject and spawner script. The spawner gameobject contains only a trigger area that encapsulates most of the map. The spawner script basically spawns enemyPrefabs at random within that trigger area (but only when an enemy dies, so there's always only 1 enemy in the map).
Implemented: Score system in inifnite mode. (GUI and script).
Implemented: Timer in infinite mode (tracks hours, minutes, seconds and milliseconds). (GUI and script).
Implemented: Player HP is now reflected in the GUI.
